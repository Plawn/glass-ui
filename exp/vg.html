<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Glass Capsule WebGL</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: #0e0e11;
}
canvas {
  width: 100vw;
  height: 100vh;
  display: block;
}
</style>
</head>
<body>
<canvas id="gl"></canvas>

<script>
const canvas = document.getElementById("gl");
const gl = canvas.getContext("webgl");
if (!gl) alert("WebGL non support√©");

function resize() {
  const dpr = devicePixelRatio || 1;
  canvas.width = innerWidth * dpr;
  canvas.height = innerHeight * dpr;
  gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener("resize", resize);
resize();

const vs = `
attribute vec2 position;
varying vec2 vUv;
void main() {
  vUv = position * 0.5 + 0.5;
  gl_Position = vec4(position, 0.0, 1.0);
}
`;

const fs = `
precision highp float;

varying vec2 vUv;
uniform vec2 uMouse;
uniform float uTime;

/* ======================
   Utils
====================== */
float sdCapsule(vec2 p, vec2 a, vec2 b, float r) {
  vec2 pa = p - a;
  vec2 ba = b - a;
  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
  return length(pa - ba * h) - r;
}

float fresnel(vec3 v, vec3 n, float f0) {
  return f0 + (1.0 - f0) * pow(1.0 - max(dot(v, n), 0.0), 5.0);
}

float noise(vec2 p) {
  return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453);
}

/* ======================
   Background
====================== */
vec3 background(vec2 uv) {
  vec3 col = mix(
    vec3(0.35, 0.45, 0.95),
    vec3(0.85, 0.95, 0.35),
    uv.x
  );

  float grid =
    step(0.97, fract(uv.x * 8.0)) +
    step(0.97, fract(uv.y * 8.0));
  col -= grid * 0.15;

  col += 0.04 * vec3(
    sin(uv.y * 12.0 + uTime),
    sin(uv.x * 10.0),
    0.0
  );

  return col;
}

void main() {
  vec2 uv = vUv;

  /* ======================
     Capsule definition
  ====================== */
  vec2 center = vec2(0.5, 0.5);
  float width = 0.55;
  float radius = 0.12;

  vec2 a = center + vec2(-width * 0.5, 0.0);
  vec2 b = center + vec2( width * 0.5, 0.0);

  float d = sdCapsule(uv, a, b, radius);

  float mask = smoothstep(0.01, -0.01, d);

  /* ======================
     Normal (SDF gradient)
  ====================== */
  vec2 e = vec2(0.002, 0.0);
  vec2 n2 = normalize(vec2(
    sdCapsule(uv + e.xy, a, b, radius) - sdCapsule(uv - e.xy, a, b, radius),
    sdCapsule(uv + e.yx, a, b, radius) - sdCapsule(uv - e.yx, a, b, radius)
  ));
  vec3 normal = normalize(vec3(n2, 0.6));

  /* ======================
     Refraction
  ====================== */
  float ior = 1.1;
  vec3 view = vec3(0.0, 0.0, 1.0);
  vec3 refr = refract(view, normal, 1.0 / ior);

  vec2 refrUv = uv + refr.xy * 0.12;

  vec3 col;
  col.r = background(refrUv + vec2(0.003, 0.0)).r;
  col.g = background(refrUv).g;
  col.b = background(refrUv - vec2(0.003, 0.0)).b;

  /* blur */
  for (int i = 0; i < 4; i++) {
    vec2 o = vec2(
      noise(uv + float(i)) - 0.5,
      noise(uv + float(i + 5)) - 0.5
    ) * 0.01;
    col += background(refrUv + o);
  }
  col /= 5.0;

  /* ======================
     Fresnel + edge
  ====================== */
  float f = fresnel(view, normal, 0.04);
  vec3 edge = vec3(1.0) * f;

  vec3 glass = col + edge * 0.9;

  /* ======================
     Composite
  ====================== */
  vec3 base = background(uv);
  vec3 finalColor = mix(base, glass, mask);

  gl_FragColor = vec4(finalColor, 1.0);
}
`;

function compile(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(s));
  }
  return s;
}

const program = gl.createProgram();
gl.attachShader(program, compile(gl.VERTEX_SHADER, vs));
gl.attachShader(program, compile(gl.FRAGMENT_SHADER, fs));
gl.linkProgram(program);
gl.useProgram(program);

const quad = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quad);
gl.bufferData(
  gl.ARRAY_BUFFER,
  new Float32Array([
    -1,-1,  1,-1, -1, 1,
    -1, 1,  1,-1,  1, 1
  ]),
  gl.STATIC_DRAW
);

const pos = gl.getAttribLocation(program, "position");
gl.enableVertexAttribArray(pos);
gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 0, 0);

const uTime = gl.getUniformLocation(program, "uTime");

let t = 0;
function render() {
  t += 0.016;
  gl.uniform1f(uTime, t);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  requestAnimationFrame(render);
}
render();
</script>
</body>
</html>
